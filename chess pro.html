<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ŸÑÿπÿ®ÿ© ÿßŸÑÿ¥ÿ∑ÿ±ŸÜÿ¨ ÿßŸÑŸÉÿßŸÖŸÑÿ©</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            color: white;
            min-height: 100vh;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            width: 100%;
            text-align: center;
        }

        .header {
            margin-bottom: 20px;
            padding: 10px;
        }

        .title {
            font-size: clamp(1.5rem, 5vw, 3.5rem);
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .crown-icon {
            color: #fbbf24;
            font-size: clamp(1.5rem, 5vw, 3rem);
        }

        .status-message {
            font-size: clamp(1.1rem, 3vw, 1.8rem);
            background-color: #334155;
            border-radius: 10px;
            padding: 12px 20px;
            display: inline-block;
            margin-top: 10px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .game-mode-selector {
            background-color: #1e293b;
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn:hover, .mode-btn:active {
            background-color: #1d4ed8;
            transform: scale(1.05);
        }

        .mode-btn.active {
            background-color: #10b981;
        }

        .ai-setup, .online-setup {
            background-color: #1e293b;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: none;
        }

        .ai-setup.active, .online-setup.active {
            display: block;
        }

        .ai-config, .peer-info {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .ai-config h3, .peer-info h3 {
            font-size: clamp(1rem, 3vw, 1.4rem);
            margin-bottom: 10px;
            color: #fbbf24;
        }

        .config-group {
            width: 100%;
            max-width: 500px;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: bold;
        }

        .difficulty-select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #334155;
            background-color: #0f172a;
            color: white;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            cursor: pointer;
            font-weight: bold;
        }

        .difficulty-select:focus {
            outline: none;
            border-color: #10b981;
        }

        .color-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .color-btn {
            flex: 1;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            transition: all 0.3s;
            border: 3px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .color-btn:hover {
            transform: scale(1.05);
        }

        .color-btn.white {
            background-color: #ffffff;
            color: #000000;
        }

        .color-btn.black {
            background-color: #1f2937;
            color: #ffffff;
        }

        .color-btn.active {
            border-color: #10b981;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }

        .peer-id-display {
            background-color: #334155;
            padding: 12px;
            border-radius: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            word-break: break-all;
            width: 100%;
            max-width: 500px;
        }

        .peer-input {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #334155;
            background-color: #1e293b;
            color: white;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        .connect-btn {
            background-color: #10b981;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connect-btn:hover, .connect-btn:active {
            background-color: #059669;
            transform: scale(1.05);
        }

        .connection-status {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .connection-status.show {
            display: block;
        }

        .connection-status.connected {
            background-color: #10b981;
        }

        .connection-status.waiting {
            background-color: #f59e0b;
        }

        .connection-status.error {
            background-color: #ef4444;
        }

        .game-board {
            background-color: #374151;
            padding: clamp(15px, 3vw, 30px);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: clamp(3px, 0.5vw, 6px) solid #0f172a;
            width: min(95vw, 720px);
            height: min(95vw, 720px);
            margin: 0 auto;
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2rem, 8vw, 5.5rem);
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .square:active {
            transform: scale(0.95);
        }

        .light {
            background-color: #fef3c7;
        }

        .dark {
            background-color: #b45309;
        }

        .selected {
            box-shadow: inset 0 0 0 clamp(3px, 0.5vw, 6px) #60a5fa;
            background-color: rgba(96, 165, 250, 0.3) !important;
        }

        .in-check {
            background-color: #ef4444 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .valid-move::after {
            content: '';
            position: absolute;
            width: clamp(18px, 3vw, 35px);
            height: clamp(18px, 3vw, 35px);
            border-radius: 50%;
            background-color: #10b981;
            opacity: 0.85;
        }

        .valid-capture::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 0;
            border: clamp(3px, 0.5vw, 6px) solid #10b981;
            opacity: 0.8;
        }

        .castling-move::after {
            content: '‚ôî';
            position: absolute;
            font-size: clamp(1.5rem, 4vw, 3rem);
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.35);
            border-radius: 50%;
            width: clamp(30px, 5vw, 60px);
            height: clamp(30px, 5vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .en-passant-move::after {
            content: '‚ôü';
            position: absolute;
            font-size: clamp(1.5rem, 4vw, 3rem);
            color: #ef4444;
            background: rgba(239, 68, 68, 0.35);
            border-radius: 50%;
            width: clamp(30px, 5vw, 60px);
            height: clamp(30px, 5vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .piece {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            transition: transform 0.2s;
            pointer-events: none;
        }

        .white-piece {
            color: #ffffff;
            text-shadow: 
                0 0 8px rgba(255, 255, 255, 0.8),
                0 0 15px rgba(255, 255, 255, 0.6),
                3px 3px 8px rgba(0, 0, 0, 1),
                -1px -1px 2px rgba(0, 0, 0, 0.8);
        }

        .black-piece {
            color: #000000;
            text-shadow: 
                0 0 8px rgba(0, 0, 0, 0.9),
                0 0 15px rgba(0, 0, 0, 0.7),
                2px 2px 6px rgba(255, 255, 255, 1),
                -1px -1px 2px rgba(255, 255, 255, 0.8);
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
            padding: 0 10px;
        }

        .reset-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: clamp(1rem, 3vw, 1.4rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .reset-btn:hover, .reset-btn:active {
            background-color: #1d4ed8;
            transform: scale(1.05);
        }

        .game-info {
            background-color: #334155;
            padding: 15px;
            border-radius: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            margin-bottom: 15px;
            width: 100%;
            max-width: 600px;
        }

        .game-info p {
            margin: 5px 0;
        }

        .special-moves-info {
            background-color: #1e293b;
            padding: 15px;
            border-radius: 10px;
            text-align: right;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .special-moves-info h3 {
            color: #fbbf24;
            margin-bottom: 12px;
            font-size: clamp(1rem, 3vw, 1.4rem);
        }

        .special-moves-info ul {
            list-style-type: none;
            padding-right: 15px;
        }

        .special-moves-info li {
            margin-bottom: 8px;
            font-size: clamp(0.85rem, 2.5vw, 1.1rem);
            line-height: 1.5;
        }

        .special-moves-info .move-icon {
            color: #10b981;
            margin-left: 6px;
            font-size: clamp(1rem, 3vw, 1.3rem);
        }

        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .promotion-container {
            background-color: #374151;
            padding: clamp(20px, 5vw, 40px);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
        }

        .promotion-title {
            font-size: clamp(1.2rem, 4vw, 2rem);
            margin-bottom: 20px;
            text-align: center;
        }

        .promotion-options {
            display: flex;
            gap: clamp(10px, 3vw, 20px);
            flex-wrap: wrap;
            justify-content: center;
        }

        .promotion-option {
            width: clamp(60px, 15vw, 110px);
            height: clamp(60px, 15vw, 110px);
            background-color: #b45309;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2.5rem, 8vw, 4.5rem);
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .promotion-option:hover, .promotion-option:active {
            background-color: #d97706;
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .header { margin-bottom: 10px; }
            .game-mode-selector { padding: 10px; gap: 8px; }
            .mode-btn { padding: 10px 15px; }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .board { width: min(70vh, 95vw); height: min(70vh, 95vw); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">
                <i class="fas fa-crown crown-icon"></i>
                ŸÑÿπÿ®ÿ© ÿßŸÑÿ¥ÿ∑ÿ±ŸÜÿ¨ ÿßŸÑŸÉÿßŸÖŸÑÿ©
            </h1>
            <div class="status-message" id="statusMessage">ÿØŸàÿ± ÿßŸÑÿ£ÿ®Ÿäÿ∂</div>
        </div>

        <div class="game-mode-selector">
            <button class="mode-btn active" id="localModeBtn">
                <i class="fas fa-users"></i>
                <span>ŸÑÿπÿ® ŸÖÿ≠ŸÑŸä</span>
            </button>
            <button class="mode-btn" id="aiModeBtn">
                <i class="fas fa-robot"></i>
                <span>ŸÑÿπÿ® ŸÖÿπ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ±</span>
            </button>
            <button class="mode-btn" id="onlineModeBtn">
                <i class="fas fa-globe"></i>
                <span>ŸÑÿπÿ® ÿ£ŸàŸÜŸÑÿßŸäŸÜ</span>
            </button>
        </div>

        <div class="ai-setup" id="aiSetup">
            <div class="ai-config">
                <h3><i class="fas fa-cog"></i> ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ±</h3>
                
                <div class="config-group">
                    <label class="config-label">
                        <i class="fas fa-brain"></i> ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµÿπŸàÿ®ÿ©:
                    </label>
                    <select id="aiDifficulty" class="difficulty-select">
                        <option value="1">‚≠ê ÿ≥ŸáŸÑ (ÿπŸÖŸÇ 1)</option>
                        <option value="2" selected>‚≠ê‚≠ê ŸÖÿ™Ÿàÿ≥ÿ∑ (ÿπŸÖŸÇ 2)</option>
                        <option value="3">‚≠ê‚≠ê‚≠ê ÿµÿπÿ® (ÿπŸÖŸÇ 3)</option>
                        <option value="4">‚≠ê‚≠ê‚≠ê‚≠ê ÿÆÿ®Ÿäÿ± (ÿπŸÖŸÇ 4)</option>
                    </select>
                </div>

                <div class="config-group">
                    <label class="config-label">
                        <i class="fas fa-chess"></i> ÿßÿÆÿ™ÿ± ŸÑŸàŸÜŸÉ:
                    </label>
                    <div class="color-buttons">
                        <button class="color-btn white active" id="whiteColorBtn">
                            <i class="fas fa-chess-king"></i>
                            <span>ÿ£ÿ®Ÿäÿ∂</span>
                        </button>
                        <button class="color-btn black" id="blackColorBtn">
                            <i class="fas fa-chess-king"></i>
                            <span>ÿ£ÿ≥ŸàÿØ</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="online-setup" id="onlineSetup">
            <div class="peer-info">
                <h3><i class="fas fa-network-wired"></i> ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ</h3>
                <div class="peer-id-display">
                    <strong>ŸÖÿπÿ±ŸÅŸÉ:</strong> <span id="myPeerId">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ÿπÿØÿßÿØ...</span>
                </div>
                <input type="text" class="peer-input" id="remotePeerId" placeholder="ÿ£ÿØÿÆŸÑ ŸÖÿπÿ±ŸÅ ÿßŸÑÿÆÿµŸÖ">
                <button class="connect-btn" id="connectBtn">
                    <i class="fas fa-link"></i> ÿßÿ™ÿµÿßŸÑ
                </button>
                <div class="connection-status" id="connectionStatus"></div>
            </div>
        </div>

        <div class="game-board">
            <div class="board" id="board"></div>
        </div>

        <div class="controls">
            <button class="reset-btn" id="resetBtn">
                <i class="fas fa-redo"></i>
                ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©
            </button>
            <div class="game-info">
                <p><i class="fas fa-chess-board"></i> ÿ±ŸÇŸÖ ÿßŸÑÿ≠ÿ±ŸÉÿ©: <span id="moveNumber">1</span></p>
                <p><i class="fas fa-hourglass-half"></i> ÿπÿØÿßÿØ ÿßŸÑŸÇÿßÿπÿØÿ© 50: <span id="halfMoveClock">0</span>/100</p>
                <p><i class="fas fa-chess-rook"></i> ÿ≠ŸÇŸàŸÇ ÿßŸÑÿ™ÿ®ŸäŸäÿ™: <span id="castlingInfo">ŸÉŸÑÿßŸáŸÖÿß</span></p>
            </div>
        </div>

        <div class="special-moves-info">
            <h3>ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™ ÿßŸÑŸÖŸÖŸäÿ≤ÿ©:</h3>
            <ul>
                <li><span class="move-icon">‚ôî</span> ÿßŸÑÿ™ÿ®ŸäŸäÿ™: ÿ≠ÿ±ŸÉÿ© ÿÆÿßÿµÿ© ÿ®ŸäŸÜ ÿßŸÑŸÖŸÑŸÉ ŸàÿßŸÑŸÇŸÑÿπÿ©</li>
                <li><span class="move-icon">‚ôü</span> ÿßŸÑÿßŸÑÿ™ŸÇÿßÿ∑ ÿ®ÿßŸÑÿ™ÿ¨ÿßŸàÿ≤: ÿπŸÜÿØŸÖÿß Ÿäÿ™ÿ≠ÿ±ŸÉ ÿßŸÑÿ®ŸäÿØŸÇ ÿÆÿ∑Ÿàÿ™ŸäŸÜ</li>
                <li><span class="move-icon">‚ôõ</span> ÿßŸÑÿ™ÿ±ŸÇŸäÿ©: ÿπŸÜÿØŸÖÿß ŸäÿµŸÑ ÿßŸÑÿ®ŸäÿØŸÇ ÿ•ŸÑŸâ ÿ¢ÿÆÿ± ÿµŸÅ</li>
            </ul>
        </div>
    </div>

    <script>
(function() {
    'use strict';

    const INITIAL = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];

    const SYMBOLS = {
        'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô',
        'k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü'
    };

    let state = {
        board: [],
        selected: null,
        player: 'white',
        moves: [],
        types: {},
        kings: {white:[7,4], black:[0,4]},
        castling: {wk:true,wq:true,bk:true,bq:true},
        enPassant: null,
        halfMove: 0,
        fullMove: 1,
        status: 'playing',
        promotion: null
    };

    let online = {
        peer: null,
        conn: null,
        mode: 'local',
        color: null
    };

    let ai = {
        difficulty: 2,
        playerColor: 'white',
        thinking: false
    };

    const el = {
        board: document.getElementById('board'),
        status: document.getElementById('statusMessage'),
        moveNum: document.getElementById('moveNumber'),
        halfClock: document.getElementById('halfMoveClock'),
        castling: document.getElementById('castlingInfo'),
        reset: document.getElementById('resetBtn'),
        local: document.getElementById('localModeBtn'),
        aiBtn: document.getElementById('aiModeBtn'),
        onlineBtn: document.getElementById('onlineModeBtn'),
        aiSetup: document.getElementById('aiSetup'),
        onlineSetup: document.getElementById('onlineSetup'),
        difficulty: document.getElementById('aiDifficulty'),
        whiteBtn: document.getElementById('whiteColorBtn'),
        blackBtn: document.getElementById('blackColorBtn'),
        peerId: document.getElementById('myPeerId'),
        remotePeer: document.getElementById('remotePeerId'),
        connect: document.getElementById('connectBtn'),
        connStatus: document.getElementById('connectionStatus')
    };

    function copy(arr) {
        return arr.map(r => [...r]);
    }

    function color(p) {
        return p ? (p === p.toUpperCase() ? 'white' : 'black') : null;
    }

    function valid(r, c) {
        return r >= 0 && r < 8 && c >= 0 && c < 8;
    }

    function showStatus(msg, type) {
        el.connStatus.textContent = msg;
        el.connStatus.className = 'connection-status show ' + type;
    }

    function initPeer() {
        online.peer = new Peer();
        online.peer.on('open', id => {
            el.peerId.textContent = id;
            showStatus('ŸÖÿπÿ±ŸÅŸÉ ÿ¨ÿßŸáÿ≤! ÿßŸÜÿ≥ÿÆŸá Ÿàÿ¥ÿßÿ±ŸÉŸá', 'waiting');
        });
        online.peer.on('connection', conn => {
            online.conn = conn;
            online.color = 'white';
            setupConn();
        });
        online.peer.on('error', err => showStatus('ÿÆÿ∑ÿ£: ' + err.type, 'error'));
    }

    function connectPeer() {
        const rid = el.remotePeer.value.trim();
        if (!rid) {
            alert('ÿ£ÿØÿÆŸÑ ŸÖÿπÿ±ŸÅ ÿßŸÑÿÆÿµŸÖ');
            return;
        }
        online.conn = online.peer.connect(rid);
        online.color = 'black';
        setupConn();
    }

    function setupConn() {
        online.conn.on('open', () => {
            const cn = online.color === 'white' ? 'ÿßŸÑÿ£ÿ®Ÿäÿ∂' : 'ÿßŸÑÿ£ÿ≥ŸàÿØ';
            showStatus('ŸÖÿ™ÿµŸÑ! ÿ£ŸÜÿ™ ' + cn, 'connected');
        });
        online.conn.on('data', handleData);
        online.conn.on('close', () => {
            showStatus('ÿßŸÜŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ', 'error');
            online.conn = null;
        });
    }

    function send(data) {
        if (online.conn && online.conn.open) {
            online.conn.send(data);
        }
    }

    function handleData(d) {
        if (d.type === 'move') {
            doMove(d.fr, d.fc, d.tr, d.tc, d.mt, false);
        } else if (d.type === 'promo') {
            doProm(d.piece, false);
        } else if (d.type === 'reset') {
            reset(false);
        }
    }

    function switchMode(m) {
        online.mode = m;
        el.local.classList.toggle('active', m === 'local');
        el.aiBtn.classList.toggle('active', m === 'ai');
        el.onlineBtn.classList.toggle('active', m === 'online');
        el.aiSetup.classList.toggle('active', m === 'ai');
        el.onlineSetup.classList.toggle('active', m === 'online');
        
        if (m === 'online' && !online.peer) initPeer();
        reset(true);
    }

    function render() {
        el.board.innerHTML = '';
        state.types = {};
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0?'light':'dark'}`;
                const pc = state.board[r][c];
                if (pc) {
                    const pe = document.createElement('div');
                    pe.className = `piece ${color(pc)==='white'?'white-piece':'black-piece'}`;
                    pe.textContent = SYMBOLS[pc];
                    sq.appendChild(pe);
                }
                if (state.selected && state.selected[0]===r && state.selected[1]===c) {
                    sq.classList.add('selected');
                }
                const mi = state.moves.findIndex(([mr,mc])=>mr===r&&mc===c);
                if (mi !== -1) {
                    const mt = state.moves[mi][2];
                    if (mt === 'castling') {
                        sq.classList.add('castling-move');
                        state.types[`${r},${c}`] = 'castling';
                    } else if (mt === 'enPassant') {
                        sq.classList.add('en-passant-move');
                        state.types[`${r},${c}`] = 'enPassant';
                    } else if (pc) {
                        sq.classList.add('valid-capture');
                    } else {
                        sq.classList.add('valid-move');
                    }
                }
                if (pc && pc.toLowerCase()==='k' && color(pc)===state.player && inCheck(state.player)) {
                    sq.classList.add('in-check');
                }
                sq.addEventListener('click', ()=>click(r,c));
                el.board.appendChild(sq);
            }
        }
    }

    function click(r, c) {
        if (state.status !== 'playing' || state.promotion) return;
        if (online.mode === 'online' && online.color && online.color !== state.player) return;
        if (online.mode === 'ai' && (state.player !== ai.playerColor || ai.thinking)) return;

        const pc = state.board[r][c];
        if (state.selected) {
            const [sr, sc] = state.selected;
            const vm = state.moves.some(([mr,mc])=>mr===r&&mc===c);
            if (vm) {
                const mt = state.types[`${r},${c}`] || 'normal';
                doMove(sr, sc, r, c, mt, true);
            } else if (pc && color(pc) === state.player) {
                state.selected = [r, c];
                state.moves = getMoves(r, c);
                render();
            } else {
                state.selected = null;
                state.moves = [];
                render();
            }
        } else if (pc && color(pc) === state.player) {
            state.selected = [r, c];
            state.moves = getMoves(r, c);
            render();
        }
    }

    function getMoves(r, c, tb = null, ig = false) {
        const b = tb || state.board;
        const p = b[r][c];
        if (!p) return [];
        const pc = color(p);
        const moves = [];
        const pl = p.toLowerCase();

        const add = (nr, nc, mt = 'normal') => {
            if (!valid(nr, nc)) return false;
            const tp = b[nr][nc];
            if (!tp) {
                moves.push([nr, nc, mt]);
                return true;
            } else if (color(tp) !== pc) {
                moves.push([nr, nc, mt]);
                return false;
            }
            return false;
        };

        if (pl === 'p') {
            const d = pc === 'white' ? -1 : 1;
            const sr = pc === 'white' ? 6 : 1;
            if (valid(r+d, c) && !b[r+d][c]) {
                add(r+d, c);
                if (r === sr && !b[r+2*d][c]) add(r+2*d, c);
            }
            for (const co of [-1, 1]) {
                const nc = c + co;
                const nr = r + d;
                if (valid(nr, nc)) {
                    const tp = b[nr][nc];
                    if (tp && color(tp) !== pc) add(nr, nc);
                }
            }
            if (state.enPassant && !tb) {
                const [er, ec] = state.enPassant;
                if (r === (pc==='white'?3:4) && Math.abs(c-ec)===1 && er===r+d) {
                    add(er, ec, 'enPassant');
                }
            }
        } else if (pl === 'n') {
            [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc])=>add(r+dr,c+dc));
        } else if (pl === 'b') {
            for (const [dr,dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
                for (let i=1; i<8; i++) if (!add(r+dr*i, c+dc*i)) break;
            }
        } else if (pl === 'r') {
            for (const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                for (let i=1; i<8; i++) if (!add(r+dr*i, c+dc*i)) break;
            }
        } else if (pl === 'q') {
            for (const [dr,dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
                for (let i=1; i<8; i++) if (!add(r+dr*i, c+dc*i)) break;
            }
        } else if (pl === 'k') {
            [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr,dc])=>add(r+dr,c+dc));
            if (!ig && !tb) {
                const kr = pc === 'white' ? 7 : 0;
                const oc = pc === 'white' ? 'black' : 'white';
                if (r===kr && c===4) {
                    if ((pc==='white'?state.castling.wk:state.castling.bk)) {
                        if (!b[kr][5] && !b[kr][6] && 
                            !attackSq(kr,4,oc,b) && !attackSq(kr,5,oc,b) && !attackSq(kr,6,oc,b)) {
                            add(kr, 6, 'castling');
                        }
                    }
                    if ((pc==='white'?state.castling.wq:state.castling.bq)) {
                        if (!b[kr][3] && !b[kr][2] && !b[kr][1] && 
                            !attackSq(kr,4,oc,b) && !attackSq(kr,3,oc,b) && !attackSq(kr,2,oc,b)) {
                            add(kr, 2, 'castling');
                        }
                    }
                }
            }
        }

        if (ig) return moves;

        return moves.filter(m => {
            const [tr, tc, mt] = m;
            const nb = copy(b);
            const piece = nb[r][c];
            const pieceL = piece.toLowerCase();

            if (mt === 'castling') {
                nb[tr][tc] = nb[r][c];
                nb[r][c] = null;
                if (tc === 6) {
                    nb[r][5] = nb[r][7];
                    nb[r][7] = null;
                } else {
                    nb[r][3] = nb[r][0];
                    nb[r][0] = null;
                }
            } else if (mt === 'enPassant') {
                nb[tr][tc] = nb[r][c];
                nb[r][c] = null;
                const cr = pc === 'white' ? tr + 1 : tr - 1;
                nb[cr][tc] = null;
            } else {
                nb[tr][tc] = nb[r][c];
                nb[r][c] = null;
            }

            let kp = pc === 'white' ? [...state.kings.white] : [...state.kings.black];
            if (pieceL === 'k') kp = [tr, tc];

            const oc = pc === 'white' ? 'black' : 'white';
            return !attackSq(kp[0], kp[1], oc, nb);
        });
    }

    function attackSq(r, c, by, b) {
        for (let rr = 0; rr < 8; rr++) {
            for (let cc = 0; cc < 8; cc++) {
                const p = b[rr][cc];
                if (p && color(p) === by) {
                    const ms = getMoves(rr, cc, b, true);
                    if (ms.some(m => m[0]===r && m[1]===c)) return true;
                }
            }
        }
        return false;
    }

    function inCheck(col) {
        const kp = col === 'white' ? state.kings.white : state.kings.black;
        const oc = col === 'white' ? 'black' : 'white';
        return attackSq(kp[0], kp[1], oc, state.board);
    }

    function doMove(fr, fc, tr, tc, mt, shouldSend) {
        const p = state.board[fr][fc];
        const pl = p.toLowerCase();
        const cap = state.board[tr][tc];

        if (mt === 'enPassant') {
            const cr = state.player === 'white' ? tr + 1 : tr - 1;
            state.board[cr][tc] = null;
        } else if (mt === 'castling') {
            if (tc === 6) {
                state.board[fr][5] = state.board[fr][7];
                state.board[fr][7] = null;
            } else {
                state.board[fr][3] = state.board[fr][0];
                state.board[fr][0] = null;
            }
        }

        state.board[tr][tc] = p;
        state.board[fr][fc] = null;

        if (pl === 'k') {
            if (state.player === 'white') {
                state.castling.wk = false;
                state.castling.wq = false;
                state.kings.white = [tr, tc];
            } else {
                state.castling.bk = false;
                state.castling.bq = false;
                state.kings.black = [tr, tc];
            }
        } else if (pl === 'r') {
            if (fr===7 && fc===0) state.castling.wq = false;
            if (fr===7 && fc===7) state.castling.wk = false;
            if (fr===0 && fc===0) state.castling.bq = false;
            if (fr===0 && fc===7) state.castling.bk = false;
        }

        if (pl === 'p' && Math.abs(tr-fr) === 2) {
            state.enPassant = [(fr+tr)/2, tc];
        } else {
            state.enPassant = null;
        }

        state.halfMove = (pl==='p' || cap) ? 0 : state.halfMove + 1;

        if (shouldSend && online.mode === 'online') {
            send({type:'move', fr, fc, tr, tc, mt});
        }

        if (pl === 'p' && (tr===0 || tr===7)) {
            state.promotion = [tr, tc];
            showPromo();
            return;
        }

        finish();
    }

    function finish() {
        if (state.player === 'black') state.fullMove++;
        state.selected = null;
        state.moves = [];
        state.player = state.player === 'white' ? 'black' : 'white';
        checkStatus();
        render();
        update();
        
        if (online.mode === 'ai' && state.status === 'playing' && state.player !== ai.playerColor) {
            setTimeout(aiMove, 500);
        }
    }

    function showPromo() {
        const modal = document.createElement('div');
        modal.className = 'promotion-modal';
        modal.innerHTML = `
            <div class="promotion-container">
                <h3 class="promotion-title">ÿßÿÆÿ™ÿ± ÿßŸÑÿ™ÿ±ŸÇŸäÿ©</h3>
                <div class="promotion-options">
                    <div class="promotion-option" data-p="q">
                        <div class="piece ${state.player==='white'?'white-piece':'black-piece'}">‚ôï</div>
                    </div>
                    <div class="promotion-option" data-p="r">
                        <div class="piece ${state.player==='white'?'white-piece':'black-piece'}">‚ôñ</div>
                    </div>
                    <div class="promotion-option" data-p="b">
                        <div class="piece ${state.player==='white'?'white-piece':'black-piece'}">‚ôó</div>
                    </div>
                    <div class="promotion-option" data-p="n">
                        <div class="piece ${state.player==='white'?'white-piece':'black-piece'}">‚ôò</div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        modal.querySelectorAll('.promotion-option').forEach(opt => {
            opt.addEventListener('click', () => {
                const piece = opt.dataset.p;
                const pp = state.player === 'white' ? piece.toUpperCase() : piece.toLowerCase();
                doProm(pp, true);
                document.body.removeChild(modal);
            });
        });
    }

    function doProm(pp, shouldSend) {
        if (!state.promotion) return;
        const [r, c] = state.promotion;
        state.board[r][c] = pp;
        state.promotion = null;
        if (shouldSend && online.mode === 'online') {
            send({type:'promo', piece:pp});
        }
        finish();
    }

    function checkStatus() {
        const has = hasLegal(state.player);
        const check = inCheck(state.player);
        if (!has) {
            state.status = check ? (state.player==='white'?'black-wins':'white-wins') : 'draw-stalemate';
        } else if (state.halfMove >= 100) {
            state.status = 'draw-50-moves';
        }
    }

    function hasLegal(col) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = state.board[r][c];
                if (p && color(p) === col) {
                    const ms = getMoves(r, c);
                    if (ms.length > 0) return true;
                }
            }
        }
        return false;
    }

    function getMsg() {
        if (online.mode === 'ai' && ai.thinking) return 'ü§ñ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± ŸäŸÅŸÉÿ±...';
        if (state.status === 'white-wins') return 'üéâ ŸÉÿ¥ ŸÖÿßÿ™! ÿßŸÑÿ£ÿ®Ÿäÿ∂ ŸäŸÅŸàÿ≤';
        if (state.status === 'black-wins') return 'üéâ ŸÉÿ¥ ŸÖÿßÿ™! ÿßŸÑÿ£ÿ≥ŸàÿØ ŸäŸÅŸàÿ≤';
        if (state.status === 'draw-stalemate') return 'ü§ù ÿ™ÿπÿßÿØŸÑ - ŸÖŸÑŸÉ ŸÖÿ≠ÿßÿµÿ±';
        if (state.status === 'draw-50-moves') return 'ü§ù ÿ™ÿπÿßÿØŸÑ - ŸÇÿßÿπÿØÿ© 50';
        const check = inCheck(state.player);
        const pn = state.player === 'white' ? 'ÿßŸÑÿ£ÿ®Ÿäÿ∂' : 'ÿßŸÑÿ£ÿ≥ŸàÿØ';
        return check ? `‚ö†Ô∏è ŸÉÿ¥! - ÿØŸàÿ± ${pn}` : `ÿØŸàÿ± ${pn}`;
    }

    function update() {
        el.status.textContent = getMsg();
        el.moveNum.textContent = state.fullMove;
        el.halfClock.textContent = state.halfMove;
        updateCast();
    }

    function updateCast() {
        const wc = [];
        const bc = [];
        if (state.castling.wk) wc.push('ÿßŸÑŸÖŸÑŸÉ');
        if (state.castling.wq) wc.push('ÿßŸÑŸÖŸÑŸÉÿ©');
        if (state.castling.bk) bc.push('ÿßŸÑŸÖŸÑŸÉ');
        if (state.castling.bq) bc.push('ÿßŸÑŸÖŸÑŸÉÿ©');
        const wt = wc.length > 0 ? `ÿßŸÑÿ£ÿ®Ÿäÿ∂: ${wc.join('ÿå ')}` : 'ŸÑÿß ÿ™ÿ®ŸäŸäÿ™ ŸÑŸÑÿ£ÿ®Ÿäÿ∂';
        const bt = bc.length > 0 ? `ÿßŸÑÿ£ÿ≥ŸàÿØ: ${bc.join('ÿå ')}` : 'ŸÑÿß ÿ™ÿ®ŸäŸäÿ™ ŸÑŸÑÿ£ÿ≥ŸàÿØ';
        el.castling.textContent = `${wt} | ${bt}`;
    }

    // AI Engine
    function evaluateBoard(b) {
        const values = {p:100, n:320, b:330, r:500, q:900, k:20000};
        const pst = {
            p: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
            n: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
            b: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,10,10,5,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,10,10,10,10,0,-10],[-10,10,10,10,10,10,10,-10],[-10,5,0,0,0,0,5,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
            r: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
            q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
            k: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
        };

        let score = 0;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = b[r][c];
                if (!p) continue;
                const pl = p.toLowerCase();
                const pc = color(p);
                const val = values[pl];
                const pstVal = pst[pl] ? pst[pl][r][c] : 0;
                
                if (pc === 'white') {
                    score += val + pstVal;
                } else {
                    score -= val + pstVal;
                }
            }
        }
        return score;
    }

    function getAllMoves(col, b) {
        const moves = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = b[r][c];
                if (p && color(p) === col) {
                    const pms = getMoves(r, c, b);
                    pms.forEach(m => moves.push({from:[r,c], to:m}));
                }
            }
        }
        return moves;
    }

    function makeAIMove(b, from, to, ep, cast) {
        const nb = copy(b);
        const [fr, fc] = from;
        const [tr, tc, mt] = to;
        const p = nb[fr][fc];
        const pl = p ? p.toLowerCase() : null;
        if (!p) return {board: nb, enPassant: ep, castling: cast};

        if (mt === 'enPassant') {
            const cr = color(p) === 'white' ? tr + 1 : tr - 1;
            nb[cr][tc] = null;
        } else if (mt === 'castling') {
            if (tc === 6) {
                nb[fr][5] = nb[fr][7];
                nb[fr][7] = null;
            } else {
                nb[fr][3] = nb[fr][0];
                nb[fr][0] = null;
            }
        }

        nb[tr][tc] = p;
        nb[fr][fc] = null;

        let newEp = null;
        if (pl === 'p' && Math.abs(tr-fr) === 2) {
            newEp = [(fr+tr)/2, tc];
        }

        let newCast = {...cast};
        if (pl === 'k') {
            if (color(p) === 'white') {
                newCast.wk = false;
                newCast.wq = false;
            } else {
                newCast.bk = false;
                newCast.bq = false;
            }
        } else if (pl === 'r') {
            if (fr===7 && fc===0) newCast.wq = false;
            if (fr===7 && fc===7) newCast.wk = false;
            if (fr===0 && fc===0) newCast.bq = false;
            if (fr===0 && fc===7) newCast.bk = false;
        }

        return {board: nb, enPassant: newEp, castling: newCast};
    }

    function minimax(b, depth, alpha, beta, maximizing, ep, cast) {
        if (depth === 0) {
            return evaluateBoard(b);
        }

        const col = maximizing ? 'white' : 'black';
        const moves = getAllMoves(col, b);

        if (moves.length === 0) {
            const kp = findKing(b, col);
            const oc = col === 'white' ? 'black' : 'white';
            const inCh = kp && attackSq(kp[0], kp[1], oc, b);
            if (inCh) return maximizing ? -999999 : 999999;
            return 0;
        }

        if (maximizing) {
            let maxEval = -Infinity;
            for (const mv of moves) {
                const result = makeAIMove(b, mv.from, mv.to, ep, cast);
                const evaluation = minimax(result.board, depth-1, alpha, beta, false, result.enPassant, result.castling);
                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const mv of moves) {
                const result = makeAIMove(b, mv.from, mv.to, ep, cast);
                const evaluation = minimax(result.board, depth-1, alpha, beta, true, result.enPassant, result.castling);
                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function findKing(b, col) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = b[r][c];
                if (p && p.toLowerCase() === 'k' && color(p) === col) {
                    return [r, c];
                }
            }
        }
        return null;
    }

    function aiMove() {
        if (ai.thinking || state.status !== 'playing') return;
        ai.thinking = true;
        
        update();

        setTimeout(() => {
            const moves = getAllMoves(state.player, state.board);
            if (moves.length === 0) {
                ai.thinking = false;
                return;
            }

            let bestMove = null;
            let bestScore = state.player === 'white' ? -Infinity : Infinity;

            for (const mv of moves) {
                const result = makeAIMove(state.board, mv.from, mv.to, state.enPassant, state.castling);
                const score = minimax(
                    result.board, 
                    ai.difficulty - 1, 
                    -Infinity, 
                    Infinity, 
                    state.player === 'black',
                    result.enPassant,
                    result.castling
                );

                if (state.player === 'white') {
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = mv;
                    }
                } else {
                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = mv;
                    }
                }
            }

            if (bestMove) {
                const [fr, fc] = bestMove.from;
                const [tr, tc, mt] = bestMove.to;
                doMove(fr, fc, tr, tc, mt || 'normal', false);
            }

            ai.thinking = false;
        }, 300);
    }

    function reset(shouldSend) {
        state.board = copy(INITIAL);
        state.selected = null;
        state.player = 'white';
        state.moves = [];
        state.types = {};
        state.kings = {white:[7,4], black:[0,4]};
        state.castling = {wk:true,wq:true,bk:true,bq:true};
        state.enPassant = null;
        state.halfMove = 0;
        state.fullMove = 1;
        state.status = 'playing';
        state.promotion = null;
        ai.thinking = false;
        if (shouldSend && online.mode === 'online' && online.conn) {
            send({type:'reset'});
        }
        render();
        update();
        
        if (online.mode === 'ai' && ai.playerColor === 'black') {
            setTimeout(aiMove, 500);
        }
    }

    function init() {
        state.board = copy(INITIAL);
        render();
        update();
        
        el.reset.addEventListener('click', () => reset(true));
        el.local.addEventListener('click', () => switchMode('local'));
        el.aiBtn.addEventListener('click', () => switchMode('ai'));
        el.onlineBtn.addEventListener('click', () => switchMode('online'));
        el.connect.addEventListener('click', connectPeer);
        
        el.difficulty.addEventListener('change', (e) => {
            ai.difficulty = parseInt(e.target.value);
        });

        el.whiteBtn.addEventListener('click', () => {
            ai.playerColor = 'white';
            el.whiteBtn.classList.add('active');
            el.blackBtn.classList.remove('active');
            if (online.mode === 'ai') reset(false);
        });

        el.blackBtn.addEventListener('click', () => {
            ai.playerColor = 'black';
            el.blackBtn.classList.add('active');
            el.whiteBtn.classList.remove('active');
            if (online.mode === 'ai') reset(false);
        });
    }

    init();
})();
    </script>
</body>
</html>